<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ–ãƒ©ã‚·ãƒ¬ã‚¹ãƒ¢ãƒ¼ã‚¿ - ã‚³ã‚¤ãƒ«å·»ãæ–¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 16px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 14px;
        }
        select, input[type="range"] {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        select {
            background: white;
            cursor: pointer;
        }
        input[type="range"] {
            cursor: pointer;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #667eea;
            font-weight: bold;
        }
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            background: white;
            width: 100%;
            height: 300px;
        }
        .motor-view {
            grid-column: 1 / -1;
            height: 400px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }
        .stat-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #2196f3;
        }
        .info-box h3 {
            margin-top: 0;
            color: #1976d2;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .comparison-card {
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ddd;
        }
        .comparison-card h4 {
            margin-top: 0;
            color: #333;
        }
        .comparison-card ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .comparison-card li {
            margin: 5px 0;
            color: #555;
        }
        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ ãƒ–ãƒ©ã‚·ãƒ¬ã‚¹ãƒ¢ãƒ¼ã‚¿ ã‚³ã‚¤ãƒ«å·»ãæ–¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
        <p class="subtitle">ã‚³ã‚¤ãƒ«ã®å·»ãæ–¹ãŒãƒ¢ãƒ¼ã‚¿ç‰¹æ€§ã«åŠã¼ã™å½±éŸ¿ã‚’ä½“æ„Ÿã—ã‚ˆã†!</p>
        
        <div class="controls">
            <div class="control-group">
                <label>å·»ãæ–¹ã‚¿ã‚¤ãƒ—</label>
                <select id="windingType">
                    <option value="concentrated">é›†ä¸­å·»ã (Concentrated)</option>
                    <option value="distributed">åˆ†å¸ƒå·»ã (Distributed)</option>
                </select>
            </div>
            <div class="control-group">
                <label>ã‚¹ãƒ­ãƒƒãƒˆæ•° <span class="value-display" id="slotDisplay">12</span></label>
                <input type="range" id="slots" min="9" max="18" step="3" value="12">
            </div>
            <div class="control-group">
                <label>æ¥µæ•° <span class="value-display" id="poleDisplay">10</span></label>
                <input type="range" id="poles" min="8" max="14" step="2" value="10">
            </div>
            <div class="control-group">
                <label>å›è»¢é€Ÿåº¦ (rpm) <span class="value-display" id="speedDisplay">1000</span></label>
                <input type="range" id="speed" min="100" max="3000" step="100" value="1000">
            </div>
            <div class="control-group">
                <label>è² è·ãƒˆãƒ«ã‚¯ (%) <span class="value-display" id="loadDisplay">50</span></label>
                <input type="range" id="load" min="0" max="100" step="10" value="50">
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="motorCanvas" class="motor-view"></canvas>
        </div>

        <div class="canvas-container">
            <canvas id="windingPatternCanvas" class="motor-view"></canvas>
        </div>

        <div class="canvas-container">
            <canvas id="torqueCanvas"></canvas>
            <canvas id="backemfCanvas"></canvas>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">å¹³å‡ãƒˆãƒ«ã‚¯</div>
                <div class="stat-value" id="avgTorque">0.85</div>
                <div class="stat-label">Nm</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">ãƒˆãƒ«ã‚¯ãƒªãƒƒãƒ—ãƒ«</div>
                <div class="stat-value" id="torqueRipple">15.2</div>
                <div class="stat-label">%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">é€†èµ·é›»åŠ›THD</div>
                <div class="stat-value" id="backemfTHD">8.5</div>
                <div class="stat-label">%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å·»ç·šä¿‚æ•°</div>
                <div class="stat-value" id="windingFactor">0.933</div>
                <div class="stat-label">-</div>
            </div>
        </div>

        <div class="comparison">
            <div class="comparison-card">
                <h4>ğŸ¯ é›†ä¸­å·»ã (Concentrated Winding)</h4>
                <ul>
                    <li>âœ… <span class="highlight">å·»ç·šãŒç°¡å˜</span> - è£½é€ ã‚³ã‚¹ãƒˆä½</li>
                    <li>âœ… çŸ­ã„ç«¯æœ«é•· - éŠ…ææ¸›å°‘</li>
                    <li>âœ… ã‚¹ãƒ­ãƒƒãƒˆå……å¡«ç‡ãŒé«˜ã„</li>
                    <li>âš ï¸ ãƒˆãƒ«ã‚¯ãƒªãƒƒãƒ—ãƒ«ãŒå¤§ãã„ (15-25%)</li>
                    <li>âš ï¸ é«˜èª¿æ³¢æˆåˆ†ãŒå¤šã„</li>
                    <li>ğŸ’¡ å°å‹ãƒ¢ãƒ¼ã‚¿ã€ã‚³ã‚¹ãƒˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–</li>
                </ul>
            </div>
            <div class="comparison-card">
                <h4>ğŸ¯ åˆ†å¸ƒå·»ã (Distributed Winding)</h4>
                <ul>
                    <li>âœ… <span class="highlight">ãƒˆãƒ«ã‚¯ãƒªãƒƒãƒ—ãƒ«å°</span> (5-10%)</li>
                    <li>âœ… æ­£å¼¦æ³¢ã«è¿‘ã„é€†èµ·é›»åŠ›</li>
                    <li>âœ… é«˜èª¿æ³¢æˆåˆ†ãŒå°‘ãªã„</li>
                    <li>âœ… åŠ¹ç‡ãŒé«˜ã„</li>
                    <li>âš ï¸ å·»ç·šãŒè¤‡é›‘ - è£½é€ ã‚³ã‚¹ãƒˆé«˜</li>
                    <li>ğŸ’¡ é«˜æ€§èƒ½ãƒ¢ãƒ¼ã‚¿ã€é™ç²›æ€§é‡è¦–</li>
                </ul>
            </div>
        </div>

        <div class="info-box">
            <h3>ğŸ“š ãƒã‚¤ãƒ³ãƒˆè§£èª¬</h3>
            <p><strong>ãƒˆãƒ«ã‚¯ãƒªãƒƒãƒ—ãƒ«:</strong> ãƒ¢ãƒ¼ã‚¿ã®å›è»¢ãƒˆãƒ«ã‚¯ã®å¤‰å‹•ã€‚å°ã•ã„ã»ã©æ»‘ã‚‰ã‹ãªå›è»¢ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</p>
            <p><strong>é€†èµ·é›»åŠ›THD:</strong> Total Harmonic Distortionã€‚æ­£å¼¦æ³¢ã‹ã‚‰ã®ãšã‚Œã‚’ç¤ºã—ã€å°ã•ã„ã»ã©é«˜èª¿æ³¢ãŒå°‘ãªãåŠ¹ç‡çš„ã§ã™ã€‚</p>
            <p><strong>å·»ç·šä¿‚æ•°:</strong> ã‚³ã‚¤ãƒ«é…ç½®ã«ã‚ˆã‚‹èµ·ç£åŠ›ã®åˆ©ç”¨åŠ¹ç‡ã€‚1ã«è¿‘ã„ã»ã©åŠ¹ç‡çš„ã§ã™ã€‚</p>
            <p><strong>é›†ä¸­å·»ã vs åˆ†å¸ƒå·»ã:</strong> é›†ä¸­å·»ãã¯1ã¤ã®ãƒ†ã‚£ãƒ¼ã‚¹(æ­¯)ã«é›†ä¸­ã—ã¦å·»ãã®ã«å¯¾ã—ã€åˆ†å¸ƒå·»ãã¯è¤‡æ•°ã®ã‚¹ãƒ­ãƒƒãƒˆã«åˆ†æ•£ã—ã¦å·»ãã¾ã™ã€‚</p>
        </div>
    </div>

    <script>
        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        let params = {
            windingType: 'concentrated',
            slots: 12,
            poles: 10,
            speed: 1000,
            load: 50,
            angle: 0
        };

        // ã‚­ãƒ£ãƒ³ãƒã‚¹å–å¾—
        const motorCanvas = document.getElementById('motorCanvas');
        const windingPatternCanvas = document.getElementById('windingPatternCanvas');
        const torqueCanvas = document.getElementById('torqueCanvas');
        const backemfCanvas = document.getElementById('backemfCanvas');
        const motorCtx = motorCanvas.getContext('2d');
        const windingPatternCtx = windingPatternCanvas.getContext('2d');
        const torqueCtx = torqueCanvas.getContext('2d');
        const backemfCtx = backemfCanvas.getContext('2d');

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®š
        function resizeCanvas() {
            motorCanvas.width = motorCanvas.offsetWidth;
            motorCanvas.height = motorCanvas.offsetHeight;
            windingPatternCanvas.width = windingPatternCanvas.offsetWidth;
            windingPatternCanvas.height = windingPatternCanvas.offsetHeight;
            torqueCanvas.width = torqueCanvas.offsetWidth;
            torqueCanvas.height = torqueCanvas.offsetHeight;
            backemfCanvas.width = backemfCanvas.offsetWidth;
            backemfCanvas.height = backemfCanvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('windingType').addEventListener('change', (e) => {
            params.windingType = e.target.value;
            update();
        });
        document.getElementById('slots').addEventListener('input', (e) => {
            params.slots = parseInt(e.target.value);
            document.getElementById('slotDisplay').textContent = params.slots;
            update();
        });
        document.getElementById('poles').addEventListener('input', (e) => {
            params.poles = parseInt(e.target.value);
            document.getElementById('poleDisplay').textContent = params.poles;
            update();
        });
        document.getElementById('speed').addEventListener('input', (e) => {
            params.speed = parseInt(e.target.value);
            document.getElementById('speedDisplay').textContent = params.speed;
            update();
        });
        document.getElementById('load').addEventListener('input', (e) => {
            params.load = parseInt(e.target.value);
            document.getElementById('loadDisplay').textContent = params.load;
            update();
        });

        // å·»ç·šãƒ‘ã‚¿ãƒ¼ãƒ³2Då±•é–‹å›³ã®æç”»
        function drawWindingPattern() {
            const ctx = windingPatternCtx;
            const width = windingPatternCanvas.width;
            const height = windingPatternCanvas.height;
            const padding = 60;
            const slotWidth = Math.min((width - padding * 2) / params.slots, 80);
            const slotHeight = 120;
            const startX = (width - slotWidth * params.slots) / 2;
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);

            // ã‚¿ã‚¤ãƒˆãƒ«
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('å·»ç·šãƒ‘ã‚¿ãƒ¼ãƒ³å±•é–‹å›³ (2D)', width / 2, 35);
            
            ctx.font = '14px Arial';
            ctx.fillText(
                params.windingType === 'concentrated' ? 'é›†ä¸­å·»ã - å„ã‚¹ãƒ­ãƒƒãƒˆ1ç›¸' : 'åˆ†å¸ƒå·»ã - è¤‡æ•°ã‚¹ãƒ­ãƒƒãƒˆã«åˆ†æ•£',
                width / 2,
                60
            );

            const phaseColors = ['#f44336', '#2196f3', '#4caf50'];
            const phaseNames = ['U', 'V', 'W'];

            if (params.windingType === 'concentrated') {
                // é›†ä¸­å·»ã - å„ã‚¹ãƒ­ãƒƒãƒˆ1ç›¸ãšã¤
                for (let i = 0; i < params.slots; i++) {
                    const x = startX + i * slotWidth;
                    const phase = i % 3;
                    
                    // ã‚¹ãƒ­ãƒƒãƒˆæ 
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = '#eee';
                    ctx.fillRect(x, centerY - slotHeight / 2, slotWidth - 5, slotHeight);
                    ctx.strokeRect(x, centerY - slotHeight / 2, slotWidth - 5, slotHeight);
                    
                    // ã‚³ã‚¤ãƒ« (ä¸Šå±¤ã¨ä¸‹å±¤)
                    const coilHeight = slotHeight * 0.35;
                    
                    // ä¸Šå±¤ã‚³ã‚¤ãƒ« (è¡Œã)
                    ctx.fillStyle = phaseColors[phase];
                    ctx.fillRect(x + 5, centerY - slotHeight / 2 + 10, slotWidth - 15, coilHeight);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 5, centerY - slotHeight / 2 + 10, slotWidth - 15, coilHeight);
                    
                    // çŸ¢å° (é›»æµæ–¹å‘ - ä¸Šå‘ã)
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('âŠ™', x + slotWidth / 2, centerY - slotHeight / 2 + 10 + coilHeight / 2);
                    
                    // ä¸‹å±¤ã‚³ã‚¤ãƒ« (å¸°ã‚Š)
                    ctx.fillStyle = phaseColors[phase];
                    ctx.globalAlpha = 0.6;
                    ctx.fillRect(x + 5, centerY + slotHeight / 2 - 10 - coilHeight, slotWidth - 15, coilHeight);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 5, centerY + slotHeight / 2 - 10 - coilHeight, slotWidth - 15, coilHeight);
                    ctx.globalAlpha = 1;
                    
                    // çŸ¢å° (é›»æµæ–¹å‘ - ä¸‹å‘ã)
                    ctx.fillStyle = 'white';
                    ctx.fillText('âŠ—', x + slotWidth / 2, centerY + slotHeight / 2 - 10 - coilHeight / 2);
                    
                    // ç›¸å
                    ctx.fillStyle = phaseColors[phase];
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(phaseNames[phase], x + slotWidth / 2, centerY);
                    
                    // ã‚¹ãƒ­ãƒƒãƒˆç•ªå·
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.fillText(`#${i + 1}`, x + slotWidth / 2, centerY + slotHeight / 2 + 25);
                }
                
                // èª¬æ˜
                ctx.fillStyle = '#333';
                ctx.font = '13px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('âŠ™: ç´™é¢æ‰‹å‰å‘ãé›»æµ', 20, height - 60);
                ctx.fillText('âŠ—: ç´™é¢å¥¥å‘ãé›»æµ', 20, height - 40);
                ctx.fillText('ç‰¹å¾´: ã‚·ãƒ³ãƒ—ãƒ«ã€ä½ã‚³ã‚¹ãƒˆã€ãƒˆãƒ«ã‚¯ãƒªãƒƒãƒ—ãƒ«å¤§', 20, height - 20);
                
            } else {
                // åˆ†å¸ƒå·»ã - è¤‡æ•°ã‚¹ãƒ­ãƒƒãƒˆã«ã¾ãŸãŒã‚‹
                const slotsPerPole = params.slots / params.poles;
                const coilPitch = Math.round(params.slots / 3); // çŸ­ç¯€å·»
                
                for (let i = 0; i < params.slots; i++) {
                    const x = startX + i * slotWidth;
                    
                    // ã‚¹ãƒ­ãƒƒãƒˆæ 
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = '#eee';
                    ctx.fillRect(x, centerY - slotHeight / 2, slotWidth - 5, slotHeight);
                    ctx.strokeRect(x, centerY - slotHeight / 2, slotWidth - 5, slotHeight);
                    
                    // å„ç›¸ã®ã‚³ã‚¤ãƒ«ã‚’é…ç½®ï¼ˆé‡ãªã‚Šè¡¨ç¾ï¼‰
                    let layerCount = 0;
                    const layerHeight = 25;
                    
                    for (let phase = 0; phase < 3; phase++) {
                        const phaseStartSlot = Math.floor(phase * params.slots / 3);
                        const phaseEndSlot = phaseStartSlot + coilPitch;
                        
                        // ã“ã®ã‚¹ãƒ­ãƒƒãƒˆãŒè©²å½“ç›¸ã®ç¯„å›²å†…ã‹
                        let isInRange = false;
                        let isGoing = false; // è¡Œã(âŠ™)ã‹å¸°ã‚Š(âŠ—)ã‹
                        
                        if (i >= phaseStartSlot && i < phaseStartSlot + Math.floor(coilPitch / 2)) {
                            isInRange = true;
                            isGoing = true;
                        } else if (i >= phaseStartSlot + Math.floor(coilPitch / 2) && i < phaseEndSlot) {
                            isInRange = true;
                            isGoing = false;
                        }
                        
                        if (isInRange) {
                            const yPos = centerY - slotHeight / 2 + 15 + layerCount * layerHeight;
                            
                            ctx.fillStyle = phaseColors[phase];
                            ctx.globalAlpha = 0.7;
                            ctx.fillRect(x + 5, yPos, slotWidth - 15, layerHeight - 3);
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x + 5, yPos, slotWidth - 15, layerHeight - 3);
                            ctx.globalAlpha = 1;
                            
                            // é›»æµæ–¹å‘
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 14px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(isGoing ? 'âŠ™' : 'âŠ—', x + slotWidth / 2, yPos + (layerHeight - 3) / 2);
                            
                            // ç›¸åï¼ˆå°ã•ãï¼‰
                            ctx.fillStyle = phaseColors[phase];
                            ctx.font = 'bold 10px Arial';
                            ctx.fillText(phaseNames[phase], x + slotWidth / 2 - 10, yPos + (layerHeight - 3) / 2);
                            
                            layerCount++;
                        }
                    }
                    
                    // ã‚¹ãƒ­ãƒƒãƒˆç•ªå·
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`#${i + 1}`, x + slotWidth / 2, centerY + slotHeight / 2 + 25);
                }
                
                // èª¬æ˜
                ctx.fillStyle = '#333';
                ctx.font = '13px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('âŠ™: ç´™é¢æ‰‹å‰å‘ãé›»æµ', 20, height - 60);
                ctx.fillText('âŠ—: ç´™é¢å¥¥å‘ãé›»æµ', 20, height - 40);
                ctx.fillText('ç‰¹å¾´: è¤‡é›‘ã€é«˜ã‚³ã‚¹ãƒˆã€æ­£å¼¦æ³¢çŠ¶åˆ†å¸ƒã€ä½ãƒªãƒƒãƒ—ãƒ«', 20, height - 20);
            }

            // å‡¡ä¾‹
            const legendX = width - 150;
            const legendY = 100;
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            phaseNames.forEach((name, i) => {
                ctx.fillStyle = phaseColors[i];
                ctx.fillRect(legendX, legendY + i * 25, 20, 15);
                ctx.fillStyle = '#333';
                ctx.fillText(`${name}ç›¸`, legendX + 25, legendY + i * 25 + 12);
            });

            // èµ·ç£åŠ›åˆ†å¸ƒã®æ¦‚å¿µå›³
            if (params.slots <= 12) {
                const mmfY = height - 150;
                const mmfHeight = 80;
                const mmfWidth = width - padding * 2;
                
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, mmfY + mmfHeight / 2);
                ctx.lineTo(width - padding, mmfY + mmfHeight / 2);
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('èµ·ç£åŠ›åˆ†å¸ƒï¼ˆUç›¸ï¼‰', width / 2, mmfY - 10);
                
                // èµ·ç£åŠ›åˆ†å¸ƒã‚’æç”»
                ctx.strokeStyle = '#f44336';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                
                const points = 200;
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const x = padding + (i / points) * mmfWidth;
                    
                    let mmf = 0;
                    if (params.windingType === 'concentrated') {
                        // é›†ä¸­å·»ã - éšæ®µæ³¢çŠ¶
                        mmf = Math.sin(angle);
                        // é«˜èª¿æ³¢æˆåˆ†ã‚’è¿½åŠ 
                        mmf += 0.15 * Math.sin(3 * angle);
                        mmf += 0.08 * Math.sin(5 * angle);
                    } else {
                        // åˆ†å¸ƒå·»ã - ã‚ˆã‚Šæ­£å¼¦æ³¢ã«è¿‘ã„
                        mmf = Math.sin(angle);
                        mmf += 0.04 * Math.sin(3 * angle);
                    }
                    
                    const y = mmfY + mmfHeight / 2 - mmf * mmfHeight * 0.4;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // ç†æƒ³æ­£å¼¦æ³¢
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const x = padding + (i / points) * mmfWidth;
                    const mmf = Math.sin(angle);
                    const y = mmfY + mmfHeight / 2 - mmf * mmfHeight * 0.4;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
                // å‡¡ä¾‹
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#f44336';
                ctx.fillText('å®Ÿéš›ã®åˆ†å¸ƒ', width - padding - 10, mmfY + 15);
                ctx.fillStyle = '#aaa';
                ctx.fillText('ç†æƒ³æ­£å¼¦æ³¢', width - padding - 10, mmfY + 30);
            }
        }

        // ãƒ¢ãƒ¼ã‚¿æ§‹é€ æç”»
        function drawMotor() {
            const ctx = motorCtx;
            const width = motorCanvas.width;
            const height = motorCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const outerRadius = Math.min(width, height) * 0.35;
            const innerRadius = outerRadius * 0.4;
            const rotorRadius = innerRadius * 0.9;

            ctx.clearRect(0, 0, width, height);

            // ã‚¹ãƒ†ãƒ¼ã‚¿å¤–å½¢
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
            ctx.fill();

            // ã‚¹ãƒ­ãƒƒãƒˆæç”»
            const slotAngle = (Math.PI * 2) / params.slots;
            ctx.fillStyle = '#fff';
            
            for (let i = 0; i < params.slots; i++) {
                const angle = i * slotAngle + params.angle * 0.01;
                const slotWidth = slotAngle * 0.4;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angle);
                
                // ã‚¹ãƒ­ãƒƒãƒˆ
                ctx.beginPath();
                ctx.moveTo(innerRadius, -slotWidth * innerRadius / 2);
                ctx.lineTo(outerRadius * 0.95, -slotWidth * outerRadius / 4);
                ctx.lineTo(outerRadius * 0.95, slotWidth * outerRadius / 4);
                ctx.lineTo(innerRadius, slotWidth * innerRadius / 2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }

            // ã‚³ã‚¤ãƒ«æç”»
            const phaseColors = ['#f44336', '#2196f3', '#4caf50'];
            
            if (params.windingType === 'concentrated') {
                // é›†ä¸­å·»ã - å„ã‚¹ãƒ­ãƒƒãƒˆã«1ç›¸
                for (let i = 0; i < params.slots; i++) {
                    const angle = i * slotAngle + params.angle * 0.01;
                    const phase = i % 3;
                    
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(angle);
                    
                    const coilRadius = (innerRadius + outerRadius * 0.95) / 2;
                    ctx.fillStyle = phaseColors[phase];
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.arc(coilRadius, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    ctx.restore();
                }
            } else {
                // åˆ†å¸ƒå·»ã - è¤‡æ•°ã‚¹ãƒ­ãƒƒãƒˆã«ã¾ãŸãŒã‚‹
                const coilsPerPhase = Math.floor(params.slots / 3);
                for (let phase = 0; phase < 3; phase++) {
                    for (let c = 0; c < coilsPerPhase; c++) {
                        const slotIndex = phase + c * 3;
                        const angle = slotIndex * slotAngle + params.angle * 0.01;
                        
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        ctx.rotate(angle);
                        
                        const coilRadius = (innerRadius + outerRadius * 0.95) / 2;
                        ctx.fillStyle = phaseColors[phase];
                        ctx.globalAlpha = 0.5 + 0.3 * Math.cos(c * Math.PI / coilsPerPhase);
                        ctx.beginPath();
                        ctx.arc(coilRadius, 0, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        ctx.restore();
                    }
                }
            }

            // ãƒ­ãƒ¼ã‚¿æç”»
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.arc(centerX, centerY, rotorRadius, 0, Math.PI * 2);
            ctx.fill();

            // æ°¸ä¹…ç£çŸ³æç”»
            const poleAngle = (Math.PI * 2) / params.poles;
            for (let i = 0; i < params.poles; i++) {
                const angle = i * poleAngle + params.angle * 0.02;
                const isNorth = i % 2 === 0;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angle);
                
                ctx.fillStyle = isNorth ? '#ff6b6b' : '#4ecdc4';
                ctx.beginPath();
                ctx.moveTo(0, -poleAngle * rotorRadius * 0.4);
                ctx.lineTo(rotorRadius * 0.85, -poleAngle * rotorRadius * 0.35);
                ctx.lineTo(rotorRadius * 0.85, poleAngle * rotorRadius * 0.35);
                ctx.lineTo(0, poleAngle * rotorRadius * 0.4);
                ctx.closePath();
                ctx.fill();
                
                // N/Sè¡¨ç¤º
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(isNorth ? 'N' : 'S', rotorRadius * 0.6, 0);
                
                ctx.restore();
            }

            // ä¸­å¿ƒè»¸
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
            ctx.fill();

            // æƒ…å ±è¡¨ç¤º
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`ã‚¹ãƒ­ãƒƒãƒˆ: ${params.slots}  æ¥µæ•°: ${params.poles}`, 20, 30);
            ctx.fillText(`å·»ãæ–¹: ${params.windingType === 'concentrated' ? 'é›†ä¸­å·»ã' : 'åˆ†å¸ƒå·»ã'}`, 20, 55);
            ctx.fillText(`å›è»¢é€Ÿåº¦: ${params.speed} rpm`, 20, 80);

            // å‡¡ä¾‹
            ctx.font = '14px Arial';
            const legendY = height - 60;
            ['Uç›¸', 'Vç›¸', 'Wç›¸'].forEach((label, i) => {
                ctx.fillStyle = phaseColors[i];
                ctx.fillRect(20, legendY + i * 20, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText(label, 40, legendY + i * 20 + 12);
            });
        }

        // ãƒˆãƒ«ã‚¯æ³¢å½¢æç”»
        function drawTorque() {
            const ctx = torqueCtx;
            const width = torqueCanvas.width;
            const height = torqueCanvas.height;
            const padding = 50;
            const graphWidth = width - padding * 2;
            const graphHeight = height - padding * 2;

            ctx.clearRect(0, 0, width, height);

            // ã‚¿ã‚¤ãƒˆãƒ«
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ãƒˆãƒ«ã‚¯æ³¢å½¢', width / 2, 25);

            // è»¸
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // ã‚°ãƒªãƒƒãƒ‰
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (graphHeight * i) / 4;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // ãƒˆãƒ«ã‚¯è¨ˆç®—ã¨ãƒ—ãƒ­ãƒƒãƒˆ
            const points = 360;
            const baseLoad = params.load / 100;
            
            // é›†ä¸­å·»ãã¨åˆ†å¸ƒå·»ãã§ãƒªãƒƒãƒ—ãƒ«ç‰¹æ€§ãŒç•°ãªã‚‹
            const rippleAmp = params.windingType === 'concentrated' ? 0.20 : 0.08;
            const harmonics = params.windingType === 'concentrated' ? 
                [1, 0.15, 0.08, 0.04] : [1, 0.05, 0.02, 0.01];
            
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let minTorque = Infinity;
            let maxTorque = -Infinity;
            let avgTorque = 0;
            
            for (let i = 0; i <= points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const x = padding + (i / points) * graphWidth;
                
                // ãƒˆãƒ«ã‚¯è¨ˆç®—(é«˜èª¿æ³¢å«ã‚€)
                let torque = baseLoad;
                harmonics.forEach((amp, h) => {
                    const harmonic = h + 1;
                    torque += rippleAmp * amp * Math.sin(harmonic * params.poles / 2 * angle + params.angle * 0.1);
                });
                
                avgTorque += torque;
                minTorque = Math.min(minTorque, torque);
                maxTorque = Math.max(maxTorque, torque);
                
                const y = height - padding - ((torque - baseLoad + rippleAmp) / (rippleAmp * 2)) * graphHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            avgTorque /= (points + 1);

            // å¹³å‡ãƒˆãƒ«ã‚¯ãƒ©ã‚¤ãƒ³
            ctx.strokeStyle = '#f44336';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const avgY = height - padding - ((avgTorque - baseLoad + rippleAmp) / (rippleAmp * 2)) * graphHeight;
            ctx.beginPath();
            ctx.moveTo(padding, avgY);
            ctx.lineTo(width - padding, avgY);
            ctx.stroke();
            ctx.setLineDash([]);

            // è»¸ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('é›»æ°—è§’ (deg)', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('ãƒˆãƒ«ã‚¯ (Nm)', 0, 0);
            ctx.restore();

            // ç›®ç››ã‚Š
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= 4; i++) {
                const value = (baseLoad + rippleAmp - (rippleAmp * 2 * i / 4)).toFixed(2);
                const y = padding + (graphHeight * i) / 4;
                ctx.fillText(value, padding - 10, y);
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let i = 0; i <= 4; i++) {
                const angle = (360 * i / 4).toFixed(0);
                const x = padding + (graphWidth * i / 4);
                ctx.fillText(angle, x, height - padding + 10);
            }

            return {
                avg: avgTorque,
                ripple: ((maxTorque - minTorque) / avgTorque * 100)
            };
        }

        // é€†èµ·é›»åŠ›æ³¢å½¢æç”»
        function drawBackEMF() {
            const ctx = backemfCtx;
            const width = backemfCanvas.width;
            const height = backemfCanvas.height;
            const padding = 50;
            const graphWidth = width - padding * 2;
            const graphHeight = height - padding * 2;

            ctx.clearRect(0, 0, width, height);

            // ã‚¿ã‚¤ãƒˆãƒ«
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('é€†èµ·é›»åŠ›æ³¢å½¢ (Back-EMF)', width / 2, 25);

            // è»¸
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, height / 2);
            ctx.lineTo(width - padding, height / 2);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();

            // ã‚°ãƒªãƒƒãƒ‰
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (graphHeight * i) / 4;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            const points = 360;
            const phaseColors = ['#f44336', '#2196f3', '#4caf50'];
            const phaseNames = ['Uç›¸', 'Vç›¸', 'Wç›¸'];
            
            // å·»ç·šä¿‚æ•°è¨ˆç®—
            const windingFactor = params.windingType === 'concentrated' ? 0.933 : 0.955;
            
            // é«˜èª¿æ³¢æˆåˆ†
            const harmonics = params.windingType === 'concentrated' ?
                [1, 0, 0.12, 0, 0.08, 0, 0.05] : // 3æ¬¡ã€5æ¬¡ã€7æ¬¡...
                [1, 0, 0.04, 0, 0.02, 0, 0.01];
            
            let thd = 0;
            harmonics.forEach((h, i) => {
                if (i > 0) thd += h * h;
            });
            thd = Math.sqrt(thd) * 100;

            // 3ç›¸æç”»
            for (let phase = 0; phase < 3; phase++) {
                ctx.strokeStyle = phaseColors[phase];
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const phaseShift = phase * (Math.PI * 2 / 3);
                    const x = padding + (i / points) * graphWidth;
                    
                    // é€†èµ·é›»åŠ›è¨ˆç®—(é€Ÿåº¦æ¯”ä¾‹ã€é«˜èª¿æ³¢å«ã‚€)
                    const speedFactor = params.speed / 1000;
                    let emf = 0;
                    harmonics.forEach((amp, h) => {
                        const harmonic = h + 1;
                        emf += windingFactor * amp * Math.sin(harmonic * (angle - phaseShift + params.angle * 0.05));
                    });
                    emf *= speedFactor;
                    
                    const y = height / 2 - (emf * graphHeight / 3);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            // è»¸ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('é›»æ°—è§’ (deg)', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('é›»åœ§ (V)', 0, 0);
            ctx.restore();

            // å‡¡ä¾‹
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            phaseNames.forEach((name, i) => {
                ctx.fillStyle = phaseColors[i];
                ctx.fillRect(width - 100, 40 + i * 20, 15, 3);
                ctx.fillStyle = '#333';
                ctx.fillText(name, width - 80, 45 + i * 20);
            });

            return {
                windingFactor: windingFactor,
                thd: thd
            };
        }

        // çµ±è¨ˆæ›´æ–°
        function updateStats(torqueData, emfData) {
            document.getElementById('avgTorque').textContent = torqueData.avg.toFixed(2);
            document.getElementById('torqueRipple').textContent = torqueData.ripple.toFixed(1);
            document.getElementById('backemfTHD').textContent = emfData.thd.toFixed(1);
            document.getElementById('windingFactor').textContent = emfData.windingFactor.toFixed(3);
        }

        // æ›´æ–°
        function update() {
            drawMotor();
            drawWindingPattern();
            const torqueData = drawTorque();
            const emfData = drawBackEMF();
            updateStats(torqueData, emfData);
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function animate() {
            params.angle += params.speed / 100;
            if (params.angle > 360) params.angle -= 360;
            
            drawMotor();
            
            requestAnimationFrame(animate);
        }

        // åˆæœŸåŒ–
        update();
        animate();

        // å®šæœŸçš„ã«ã‚°ãƒ©ãƒ•æ›´æ–°
        setInterval(() => {
            drawWindingPattern();
            const torqueData = drawTorque();
            const emfData = drawBackEMF();
            updateStats(torqueData, emfData);
        }, 100);
    </script>
</body>
</html>